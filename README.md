# Adapters

## Постановка задачи

Разработать библиотеку адаптеров для упрощения работы с контейнерами и алгоритмами, реализующую ленивые вычисления. Основная идея заключается в создании удобного и читаемого синтаксиса для обработки данных, подобного **конвейерам в Unix-системах**.

### Пример

Задача применения нескольких алгоритмов к контейнеру:  

```cpp
std::vector<int> v = {1, 2, 3, 4, 5, 6};
std::vector<int> result;

// Используем стандартные алгоритмы STL
std::copy_if(v.begin(), v.end(), std::back_inserter(result), [](int i) { return i % 2; });
std::transform(result.begin(), result.end(), result.begin(), [](int i) { return i * i; });

for (int i : result)
    std::cout << i << " ";
```

Эту задачу можно решить более элегантно с помощью адаптеров:

```cpp
std::vector<int> v = {1, 2, 3, 4, 5, 6};

auto removed = v | filter([](int i) { return i % 2; });
auto result = removed | transform([](int i) { return i * i; });

for (int i : result)
    std::cout << i << " ";
```

Или короче, используя ленивый конвейер:

```cpp
std::vector<int> v = {1, 2, 3, 4, 5, 6};

for (int i : v | filter([](int i) { return i % 2; }) | transform([](int i) { return i * i; }))
    std::cout << i << " ";
```

---

## Требуемые адаптеры

Реализовать следующие адаптеры:

1. **`transform`**  
   Преобразует элементы контейнера (аналог алгоритма `std::transform`).
2. **`filter`**  
   Фильтрует элементы по заданному условию (предикату).
3. **`take`**  
   Берет первые N элементов.
4. **`drop`**  
   Пропускает первые N элементов.
5. **`reverse`**  
   Реверсирует элементы контейнера.
6. **`keys`**  
   Извлекает ключи из ассоциативного контейнера.
7. **`values`**  
   Извлекает значения из ассоциативного контейнера.

### Требования к адаптерам

- Должны поддерживать ленивые вычисления.
- Классы должны удовлетворять требованиям для использования в `range-based for` (см. [cppreference](https://en.cppreference.com/w/cpp/language/range-for)).

---

## Ограничения

- Реализация должна быть компактной и использовать STL только для базовых контейнеров и алгоритмов.

---

## Тестирование

- Все адаптеры должны быть покрыты тестами с использованием фреймворка **Google Test**.
